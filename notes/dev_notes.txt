db.user.find({ 'mc_member.Mobile': '15800336184' })
db.user.find({ _id: ObjectId('5d6b973ce87c084e92636478') })
db.admin_gb.find({ _id: ObjectId('5d69fbc6e87c084e92635e3b') })
db.admin_order.find({ group_id: ObjectId('5d69fbc6e87c084e92635e3b') })
more /hd1/forever_logs/gOlQ.log | grep -C 20 '2019-8-31 12:46:5'

我很少有机会写对事情的理解给别人看，这一次借这个机会，写一点对前端技术的浅见。
肯定有许多不足之处，非常欢迎教导指正。

前端的每一需求的每一步细节都有多种处理方式能达到相同的效果，因此不同的人来应对同一种需求，实现方式都很难完全一样。
即便是同一个人，重复应对同一个需求，每两次实现方式之间都会有不同的细节处理。
比如就文本垂直居中这一件事情，CSS 里就有至少 3 种方法，JS 也可以做到，HTML 本身也有它的办法，各种方法还可以掺和着来。
因此通常大家会感觉，前端是没有边界的，因为技术手段看起来无穷无尽，没有一种路径是相同的。
JS 的生态圈就是“没有边界”的一个旁证，它一直在增长、变化，有时甚至让人感觉学不过来。

每做一步，选项太多会让人感觉挑花了眼、无所适从。
比如流行的打包工具就有 5、6 种，项目创建工具又有 10 多种，流行的框架有 4 种，组件库多不胜数，还有各个环节的小工具小插件浩如繁星。
其中每一项都有自己的技术栈，虽然技术栈之间必然有交集，但如果要深度依赖，各自的学习曲线都不会短。
光是严肃地选一条路径，这个成本就很可观了。所以实际做项目，往往就是挑最熟悉的用，这样至少学习成本下降了。

但是我理解前端这个领域，其实和别的领域没有特别本质的区别，所有的技术都是为需求服务的。
几个问题在立项时就可以回答，为后续决策圈出一个大概轮廓：
1. 成本（人月）是不是约束？
2. 我们能找到的人（认知层次、能力、经验相当的），偏重于专精还是多面手？
3. 我们做的产品会生存多久？（不是希望生存多久）
4. 我们做的产品给谁用？（平台、群体、规模）

一般有个目标想要达到，我会有三连问：有什么？要什么？给什么？
问题 1、2 基本就是了解自身的两个情况：有什么？能给项目什么？
问题 3、4 是大致确定：我们要什么？

问题 1 能一定程度上决定我们怎么选技术路径，2、3、4 能大致确定我们的选择目标的特征。
问题 1 的答案决定自己造轮子是不是一个选项。
问题 2 的答案决定所选技术的特征（技术是通用型，还是偏重于解决了某类问题；大家接受的程度）。
问题 3 的答案决定所选的技术当前活跃度，大概的剩余寿命。
问题 4 的答案决定技术的偏向，这个会落到目标产品的特征当中（要不要响应式、重不重交互等）。

当然还有很多其它问题可以问，但是问题太多，也会带来新的问题。上面列出的是为了圈定技术路径，所以适可而止了。
上面这些问题的答案，会缩小选项池，甚至直接确定选项。

我对开发，具体到前端开发，做决定时，会找一个根本问题：我们要解决的问题是什么？然后接着三连问。

对于所有前面列出的多少种技术，我肯定是不能说全部了解的，但是多数技术我理解都是想让项目更可控。
所谓高内聚、低耦合原则是大多数框架的共同原则（有些例外的，比如 React，很多时候让文档结构和行为耦合在一起了，但是从另一角度看，它也让组件本身内聚了），归根结底是为了将变化限制在可控的范围当中。
理解这个原则之后，大多数的技术为什么会形成当前的结构，我感觉都不难理解。

前端技术的发展趋势我没有特别深刻的认知，在这方面我是缺乏前瞻性的。不过也可以勉强谈一点========（平台、技术的特征）。

行为比较散，但是核心的观点只有一个，就是：前端的边界是需求。
谢谢耐心阅读！欢迎指教！

# 开发信息
#* 图解开源协议 https://www.cnblogs.com/KruceCoder/p/7991052.html
#* 安装 tensorflow 成功的前提是安装 python3.5.2，然后 pip install --upgrade https://storage.googleapis.com/tensorflow/windows/cpu/tensorflow-1.0.0-cp35-cp35m-win_amd64.whl
升级的方法：
pip search --version tensorflow
pip install --upgrade tensorflow==1.1.0rc1

# 代码链接
#* SVN http://earth.bao.ac.cn/svn/gsegment/trunk/***
#* GIT git@github.com:qixiaofeng/***

# 常用指令
#* 软链接 ln -s target_to_link link_name
#* 在 linux 下，两种使命令脱离 shell 执行的方法：
#*# nohup command_and_paramters &
#*# command_and_paramters </dev/null &>/dev/null &
#* 查 linux 已占用端口 sudo lsof -i -P -n | grep LISTEN
#* GIT 推送本地工程到远程空工程
git pull origin master --allow-unrelated-histories
git remote add origin git@blablabla:url
git push -u origin master
#* 在 windows 下使命令脱离 cmd 执行的方法（关闭 cmd 后进程将退出，因此大多数情况无效）：
start "command_name" /B command_and_paramters > somefile.txt

# Windows 中安装 MongoDB 服务
#* 创建数据文件和日志文件目录；
#* 以下列格式创建配置：
systemLog:
  destination: file
  path: c:\data\log\mongod.log
storage:
  dbPath: c:\data\db
#* 安装服务：mongod.exe --config "config/file/path" --install
#* 启动：net start MongoDB
# Windows 10 中在管理员权限下的 PowerShell 中（c:/windows/system32/windowspowershell 目录下找 powershell）关闭防火墙：
Set-NetFirewallProfile -Profile Domain, Public,Private -Enabled false

# 常用正则
#* 分节删除：\r\n-+\r\n\r\n分节阅读\s.+\r\n\r\n

# Web 前端开发跨域 Chrome 设置
"C:/Program Files (x86)/Google/Chrome/Application/chrome.exe" --disable-web-security --user-data-dir="D:/TempDocs/chrome_data/"
Windows 下可创建快捷方式并添加参数

# Windows 重启 LxssManager 服务可重启 Linux 子系统

# Java 执行指定 jar 包中的指定 class 和 library path 的命令行：
java -Djava.library.path=dir/path -cp xxx.jar xxx.xxx.ClassName
# eclipse 中配置 ${user} 变量的方法：在 eclipse.ini 中的 -vmargs 之后一行添加 -Duser.name=XXX

# SQL 拷贝表数据语句：insert into table_1 (column_1, colum_2) select column_a, column_b from table_2;
# 如果 select column_names from table; 的 column_names 中有常量值，比如数值或字符串，则在返回结果中该列是该常量值
# select 语句可以用在 from 和 where 之后
# from 之后可以放多个表（或 select 语句），此时 from 对应的 select 语句中所有列需带表名

# SVN 解决树冲突，需先 svn resolve --accept=working，accept 的参数值随需要而定