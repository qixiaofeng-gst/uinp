2020-5-15：
- 当前目标：让 minicheetah 可以在这个 motion-imitation 工程中被训练、测试。步骤细化：
  - 找到 env.reset 方法里面，设置被训练的 robot 和参考的 robot 的状态设置的逻辑。
- 接着吐槽：
  - 配置、参数、常量、变量这些影响运行时行为的东西，被用的太随便了，这居然还是 google 的代码。
  - 依赖结构也没有什么设计，经过设计的东西，必然能感受到一致性、可维护性、可扩展性的体现，我目前能感受到的很少。
  - 运行时依赖、结构性依赖（继承依赖、包含依赖等）没有怎么区分，可以想象这些代码产生时，原则是怎么可行、怎么快就怎么来（我们目前的状态与之类似）。
  - 模块（目录）、类、方法的拆分也有一些槽点，不过能感觉到，作者们还是有许多好的习惯的，至少在前面列出的缺憾中，还能把工程做出来，就说明好习惯的力量了。
    - 好习惯的点：关键方法都有文档，说明至少这些方法是精心考虑过的。
    - 另一点：目录划分的粒度是合理的，里面的内容也都尽力按类别聚集的，保证了至少读者（作者自己也是读者的）理解这一层的障碍不那么多。
    - 还有：虽然设计（比如 env 的继承关系和使用关系）没能保持一致或者选用更合适的，但是至少能看出是投入了一些力气尝试解构和拆分，降低了一些维护成本和理解成本。
  - 对于一篇论文来说，这些代码可能就够了，对于我们来说，这些代码其实是不合适的，在这种思路上开发的成本有点高（至少在这个基础上迭代的成本还是有点高的）。
  - 当然，选取和设计一套原则也是有成本的，可以理解这个工程的状态，也可以理解我们现在的状态。不过我感觉想整体走得更稳更远更快不应该止步于此。
- 仿真环境选型的一点考虑：
  - 目前实际接触了 raisimLib、pybullet、webots（webots 我这里是没有深入看的，不过 gibbon 应该有发言权），还有 dacong。
  - 我们现在的状态是没有做一个选择，可能也尚不明确怎么做这个选择。我尝试看看能不能明确点。
  - 我们做选择的最重要的依据应该是一个核心要素：时间成本。要快，而且要长期的快（很多短期快的决定，其实长期并不快，当然这个权衡也要考虑我们想走多长）。
  - 我因为视野一直局限在开发这个领域，所以只说开发的方面。我们现在大概四个方面：写代码、本地调试、联合调试、真机部署。
  - 仿真环境主要影响前三个方面，它的易用性影响写代码的效率，仿真的准确性、实时性影响两个调试阶段。
  - 对比起来比较难的是，这三个特性都是不好量化的，尤其是后两者，需要非常专业的知识才能测出来，因此目前只能用易用性做不太精确的对比。
  - 目前看来 raisimLib 易用性是最差的，文档不完备，稳定性差。dacong 做得比 raisimLib 没好多少，它有个优势是它能比较平滑地支持真机部署方面。
  - pybullet 和 webots 在我目前看来易用性方面应该是半斤八两，webots 有收费选项，这个略有减分，因为可能只有给钱才能得到技术支持，这会让它的生态圈比更开放的质量相当的项目小很多。
  - pybullet 比较活跃，品质也应该是有保障的，它应该作为一个候选者；dacong 在我看来是另一个候选者，主要考虑的是它对第四方面的支持。
  - 更长远的看一看，我们将来要自己攒狗的话，dacong 可能到时候需要我们自己迭代了，这基本抵消了它支持平滑的真机部署的优势。
  - 在我的角度，pybullet 是眼前比较合适的仿真环境的选项。它除了易用性之外，目前很多比较活跃的机器人项目都和它或多或少有交集。
  - 对 AI 小组来说，pybullet 是特别合适的，语言上、生态上都有优势。对于用 C++ 的其他小组来说，pybullet 的内核其实就是 C++ 的，阻碍也很少。
- 自动化的（还是开发方面）一点考虑：
  - 我们现在可能没有考虑测试用例的设计和持续集成，或者是考虑过但是觉得这个时间点没有可行性，又或是成本顾虑，这个状态我理解它是由于有一些基本的条件没有达成而在这个状态。但是我感觉早一点考虑它们，对长远的效率是好的。
  - 本地调试、联合调试和真机部署方面，都应该各自有一组测试用例（特指自动化的，用代码支持的测试）被设计、实现出来，形成我们的基准线（随项目整体进展变动的基准线）。
  - 同时测试用例的设计还会反向驱动产品逻辑的完善和细化，产品逻辑的发展又会正向驱动开发进程，我感觉应该能形成一个良性循环。
  - 有了测试用例，就可以考虑自动持续集成了，各小组的代码有提交的时候，自动的编译、安装、测试、集成测试，甚至到最后部署真机跑用例。
  - 这样的话一是能反向约束大家把代码质量提到一个水平线上，降低继续迭代的成本。
  - 第二是随着测试用例的演变，大家能更清楚地看到我们项目的进展、我们产品的状态。
  - 最后，从写代码到收到反馈的这个周期被缩短，对各位软件工程师的开发效率也是有帮助的（各个层次，编译、运行、集成、部署这些层次的错误都能被更快捕捉到）。

各位头脑，我对两点注意到的东西做了一些简单的分析，你们可以瞅瞅在当下有没有价值。写在 wiki 里：http://wiki.corp.hachibot.com/pages/viewpage.action?pageId=9667565 ，5-15 号的工作简报的最后两个列表，有关仿真环境和自动化集成。我写东西喜欢用列表，感觉看起来不会太费眼，但是可能形式上不甚合理，大家包涵哈。

```
world（目前只有地面）、robot 在 envs/locomotion_gym_env.py reset 方法里被创建（在 200 行左右）。
ref_model 在 envs/env_wrappers/imitation_task.py 里被创建、更新、渲染。
```

_______ _______
quick-memo:
- to-har -> har-rsync

2020-4-28 会：
1. 电机驱动器的问题，芯片：温度传感器、位置传感器、电流回馈，有损去噪，是用 raw 数据作为 RL 输入还是用去噪过的？
   张钰：不用，没有差异，刘博士赞同
2. 八字腿是 reward 设计的问题。
3. 输入维度增加可能有用，但目前用处未知。

warning: ‘hachi::PyWrapperingMotionController’
 declared with greater visibility than the type of its field
  ‘hachi::PyWrapperingMotionController::controllerInPy’
see: https://pybind11.readthedocs.io/en/stable/faq.html

连接 mini-cheetah，接网线，PC 关 wifi，手动配置 IP 为 10.0.0.2，子网：255.255.255.0，DNS：10.0.0.1。
然后 ssh user@10.0.0.36，密码 i-b。`cd hachidog/build` 然后 `/bin/bash ./run_mc.sh ./mit_ctrl`。

1. 刘博士提议：数值可视化监控的工具，主要针对狗狗的状态（关节位置、扭矩等）数值。

_______ _______
1 配置文件切换模式，硬件时遥控器切换模式。
  AI 这边的可执行内容在 so 文件里。
2 调试时用 rosbag 录制的所有消息。
  CMake 都保证存在冲突的库依赖放到相互独立的地方。

PD(proportional-derivative) controller: TeX[[ f = k_p (x_{ref}-x) + k_d (v_{ref}-v), k_p = \omega_n^2, k_d = 2 \xi \omega_n ]]

Useful information:
1. pybind11 is the bridge between c++ and python
2. check Qt installation: qtdiag
3. URDF: Unified Robot Description Format; SDF: Simulation Description Format; MJCF: Multi-Joint dynamics with Contact Format
4. Eigen: C++ template library for matrix/verctor/numerical solver, pure header files without binary library
5. Executables for Qt might start correctly with -qt=qt5 as argument

这两天对需求和代码粗浅的理解之后，大概弄了个分层设计（没什么高深的，分个层方便描述、理解和沟通，预期每一层都至少是一个独立工程）：
1. 描述格式适配（输入层）
   - 输入：URDF，SDF，MJCF 等格式
   - 输出：单一格式的机器人描述，比如 URDF，或者我们自定
   - 对不同目标（模拟器或机器人）可能要进行数值调整，因此输出可能针对不同目标生成独立的版本
   - 可能是个工具集合，针对不同格式和目标有不同工具
2. 机器人控制模型训练（训练层，核心工程）
   - 输入：机器人描述，环境描述，训练过的控制模型
   - 输出：训练过的控制模型
   - 预期是 C++ 和 Python 混合的工程
   - 与输入层类似，可能针对不同目标需要不同的训练环境
   - 本层的输入输出在概念上是有不同目标之分的，但是代码逻辑上是不用区分不同目标的
   - 本层的输入输出的内容格式和训练逻辑是稳定的、一致的
   - 模型的训练预期是要依赖某种模拟器的，最好能选一个开源的模拟器
3. 机器人控制模型导出（转译/输出层）
   - 输入：训练过的控制模型
   - 输出：用于控制机器人或模拟器的可执行程序
   - 主要需要将训练过的控制模型针对不同目标进行处理
   - 可能是个工具集合，针对不同目标有不同工具
